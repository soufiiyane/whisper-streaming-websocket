<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whisper Live Transcription & Translation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .language-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #e9ecef;
        }

        .language-controls label {
            font-size: 14px;
            font-weight: bold;
            color: #555;
        }

        .recording .language-controls {
            background-color: #e8f5e8;
            border-color: #4CAF50;
        }

        .recording .language-controls label {
            color: #2e7d32;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        .start-btn {
            background-color: #4CAF50;
            color: white;
        }

        .start-btn:hover {
            background-color: #45a049;
        }

        .stop-btn {
            background-color: #f44336;
            color: white;
        }

        .stop-btn:hover {
            background-color: #da190b;
        }

        select {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ddd;
            font-size: 14px;
        }

        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }

        .status.listening {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .output-section {
            margin: 20px 0;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }

        .output-section h3 {
            margin-top: 0;
            color: #333;
        }

        .transcript,
        .translation {
            min-height: 60px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #e9ecef;
            font-size: 16px;
            line-height: 1.5;
            max-height: 200px;
            overflow-y: auto;
        }

        .partial {
            color: #666;
            font-style: italic;
        }

        .final {
            color: #000;
        }

        .voice-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #ccc;
            margin-left: 10px;
            transition: background-color 0.3s;
        }

        .voice-indicator.active {
            background-color: #4CAF50;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        .server-input {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ddd;
            font-size: 14px;
            width: 200px;
        }

        .translation-section {
            display: none;
        }

        .translation-section.enabled {
            display: block;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>üé§ Whisper Live Transcription & Translation</h1>

        <div class="controls">
            <button id="recordBtn" class="start-btn">üé§ Start Recording</button>
            <input type="text" id="serverUrl" class="server-input" value="ws://localhost:43007"
                placeholder="WebSocket URL">

            <div class="language-controls">
                <label for="sourceLanguageSelect">Speak in:</label>
                <select id="sourceLanguageSelect">
                    <option value="auto">Auto Detect</option>
                    <option value="en" selected>English</option>
                    <option value="es">Spanish</option>
                    <option value="fr">French</option>
                    <option value="de">German</option>
                    <option value="it">Italian</option>
                    <option value="pt">Portuguese</option>
                    <option value="ja">Japanese</option>
                    <option value="ko">Korean</option>
                    <option value="zh">Chinese</option>
                    <option value="ar">Arabic</option>
                    <option value="ru">Russian</option>
                    <option value="hi">Hindi</option>
                    <option value="nl">Dutch</option>
                    <option value="pl">Polish</option>
                    <option value="tr">Turkish</option>
                    <option value="sv">Swedish</option>
                    <option value="da">Danish</option>
                    <option value="no">Norwegian</option>
                    <option value="fi">Finnish</option>
                    <option value="cs">Czech</option>
                    <option value="sk">Slovak</option>
                    <option value="hu">Hungarian</option>
                    <option value="ro">Romanian</option>
                    <option value="bg">Bulgarian</option>
                    <option value="hr">Croatian</option>
                    <option value="sl">Slovenian</option>
                    <option value="et">Estonian</option>
                    <option value="lv">Latvian</option>
                    <option value="lt">Lithuanian</option>
                    <option value="uk">Ukrainian</option>
                </select>

                <span style="margin: 0 10px;" id="translationArrow">‚Üí</span>

                <label for="targetLanguageSelect" id="translateLabel">Translate to:</label>
                <select id="targetLanguageSelect">
                    <option value="es">Spanish</option>
                    <option value="en">English</option>
                    <option value="fr" selected>French</option>
                    <option value="de">German</option>
                    <option value="it">Italian</option>
                    <option value="pt">Portuguese</option>
                    <option value="ja">Japanese</option>
                    <option value="ko">Korean</option>
                    <option value="zh">Chinese</option>
                    <option value="ar">Arabic</option>
                    <option value="ru">Russian</option>
                    <option value="hi">Hindi</option>
                    <option value="nl">Dutch</option>
                    <option value="pl">Polish</option>
                    <option value="tr">Turkish</option>
                    <option value="sv">Swedish</option>
                    <option value="da">Danish</option>
                    <option value="no">Norwegian</option>
                    <option value="fi">Finnish</option>
                    <option value="cs">Czech</option>
                    <option value="sk">Slovak</option>
                    <option value="hu">Hungarian</option>
                    <option value="ro">Romanian</option>
                    <option value="bg">Bulgarian</option>
                    <option value="hr">Croatian</option>
                    <option value="sl">Slovenian</option>
                    <option value="et">Estonian</option>
                    <option value="lv">Latvian</option>
                    <option value="lt">Lithuanian</option>
                    <option value="uk">Ukrainian</option>
                </select>
            </div>

            <span>Voice Activity: <span class="voice-indicator" id="voiceIndicator"></span></span>
        </div>

        <div id="status" class="status" style="display: none;"></div>

        <div class="output-section">
            <h3 id="originalLabel">üéØ Original (English)</h3>
            <div id="transcript" class="transcript">Click "Start Recording" to begin transcription...</div>
        </div>

        <div class="output-section translation-section" id="translationSection">
            <h3 id="translationLabel">üåç Translation (French)</h3>
            <div id="translation" class="translation">Translation will appear here...</div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/hark@1.2.3/hark.bundle.js"></script>
    <script>
        class WhisperClient {
            constructor() {
                this.socket = null;
                this.isRecording = false;
                this.audioContext = null;
                this.speechEvents = null;
                this.transcriptText = '';
                this.translationText = '';
                this.translationEnabled = false;

                this.initializeElements();
                this.setupEventListeners();
                this.checkTranslationSupport();
            }

            initializeElements() {
                this.recordBtn = document.getElementById('recordBtn');
                this.serverUrl = document.getElementById('serverUrl');
                this.sourceLanguageSelect = document.getElementById('sourceLanguageSelect');
                this.targetLanguageSelect = document.getElementById('targetLanguageSelect');
                this.status = document.getElementById('status');
                this.transcript = document.getElementById('transcript');
                this.translation = document.getElementById('translation');
                this.voiceIndicator = document.getElementById('voiceIndicator');
                this.originalLabel = document.getElementById('originalLabel');
                this.translationLabel = document.getElementById('translationLabel');
                this.translationSection = document.getElementById('translationSection');
                this.translationArrow = document.getElementById('translationArrow');
                this.translateLabel = document.getElementById('translateLabel');
            }

            setupEventListeners() {
                this.recordBtn.addEventListener('click', () => this.toggleRecording());

                // Language change handlers
                const updateLanguages = () => {
                    const sourceLanguage = this.sourceLanguageSelect.value;
                    const targetLanguage = this.targetLanguageSelect.value;

                    // Prevent same language for source and target (except auto)
                    if (sourceLanguage !== 'auto' && sourceLanguage === targetLanguage) {
                        this.showStatus('Source and target languages cannot be the same!', 'error');
                        return;
                    }

                    // Send language update to server
                    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                        this.socket.send(JSON.stringify({
                            type: 'setLanguages',
                            sourceLanguage: sourceLanguage,
                            targetLanguage: targetLanguage
                        }));
                    }

                    // Update UI labels
                    this.updateLanguageLabels(sourceLanguage, targetLanguage);

                    // Show feedback when recording is active
                    if (this.isRecording) {
                        this.showStatus('üîÑ Language settings updated during recording!', 'listening');
                    }
                };

                this.sourceLanguageSelect.addEventListener('change', updateLanguages);
                this.targetLanguageSelect.addEventListener('change', updateLanguages);

                // Set initial languages
                updateLanguages();
            }

            async checkTranslationSupport() {
                // Check if server supports translation by connecting briefly
                try {
                    const testSocket = new WebSocket(this.serverUrl.value);
                    testSocket.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        if (data.type === 'status' && data.message.includes('Translation: Enabled')) {
                            this.translationEnabled = true;
                            this.translationSection.classList.add('enabled');
                        } else if (data.type === 'status') {
                            this.translationEnabled = false;
                            this.translationSection.classList.remove('enabled');
                            this.hideTranslationControls();
                        }
                        testSocket.close();
                    };
                    testSocket.onerror = () => {
                        // Server not available, assume no translation
                        this.translationEnabled = false;
                        this.hideTranslationControls();
                    };
                } catch (error) {
                    this.translationEnabled = false;
                    this.hideTranslationControls();
                }
            }

            hideTranslationControls() {
                this.translationArrow.style.display = 'none';
                this.translateLabel.style.display = 'none';
                this.targetLanguageSelect.style.display = 'none';
            }

            async toggleRecording() {
                if (this.isRecording) {
                    this.stopRecording();
                } else {
                    await this.startRecording();
                }
            }

            async startRecording() {
                try {
                    // Connect to WebSocket
                    this.socket = new WebSocket(this.serverUrl.value);

                    this.socket.onopen = () => {
                        this.showStatus('üîó Connected to Whisper server', 'listening');
                        // Send start message
                        this.socket.send(JSON.stringify({ type: 'start' }));
                    };

                    this.socket.onmessage = (event) => {
                        console.log('Received message:', event.data);
                        const data = JSON.parse(event.data);
                        console.log('Parsed data:', data);
                        this.handleMessage(data);
                    };

                    this.socket.onerror = () => {
                        this.showStatus('‚ùå WebSocket connection error', 'error');
                    };

                    this.socket.onclose = () => {
                        this.showStatus('üîå Connection closed', 'error');
                    };

                    // Get microphone
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            sampleRate: 16000,
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true
                        }
                    });

                    // Voice activity detection
                    this.speechEvents = hark(stream, { threshold: -50 });
                    this.speechEvents.on('speaking', () => {
                        this.voiceIndicator.classList.add('active');
                    });
                    this.speechEvents.on('stopped_speaking', () => {
                        this.voiceIndicator.classList.remove('active');
                    });

                    // Audio processing
                    this.audioContext = new AudioContext({ sampleRate: 16000 });
                    const source = this.audioContext.createMediaStreamSource(stream);
                    const processor = this.audioContext.createScriptProcessor(4096, 1, 1);

                    processor.onaudioprocess = (e) => {
                        if (this.isRecording && this.socket && this.socket.readyState === WebSocket.OPEN) {
                            const inputData = e.inputBuffer.getChannelData(0);
                            const pcmData = this.float32ToPCM16(inputData);
                            this.socket.send(pcmData);
                        }
                    };

                    source.connect(processor);
                    processor.connect(this.audioContext.destination);

                    this.isRecording = true;
                    this.transcriptText = '';
                    this.translationText = '';
                    this.recordBtn.textContent = '‚èπÔ∏è Stop Recording';
                    this.recordBtn.className = 'stop-btn';
                    document.body.classList.add('recording');
                    this.transcript.textContent = 'Listening for speech...';
                    if (this.translationEnabled) {
                        this.translation.textContent = 'Translation will appear here...';
                    }

                } catch (error) {
                    this.showStatus('‚ùå Error: ' + error.message, 'error');
                    console.error('Error starting recording:', error);
                }
            }

            stopRecording() {
                this.isRecording = false;

                if (this.socket) {
                    this.socket.send(JSON.stringify({ type: 'stop' }));
                    this.socket.close();
                    this.socket = null;
                }

                if (this.speechEvents) {
                    this.speechEvents.stop();
                    this.speechEvents = null;
                }

                if (this.audioContext) {
                    this.audioContext.close();
                    this.audioContext = null;
                }

                this.recordBtn.textContent = 'üé§ Start Recording';
                this.recordBtn.className = 'start-btn';
                document.body.classList.remove('recording');
                this.voiceIndicator.classList.remove('active');
                this.showStatus('‚èπÔ∏è Recording stopped', '');
            }

            handleMessage(data) {
                console.log('Handling message:', data);

                switch (data.type) {
                    case 'transcription':
                        console.log('Processing transcription:', data);
                        if (data.text && data.text.trim()) {
                            if (data.isFinal) {
                                // Final transcription - add to permanent text
                                this.transcriptText += data.text + ' ';
                                this.transcript.innerHTML = this.transcriptText;
                                console.log(`Final: "${data.text}" (${data.start}ms - ${data.end}ms)`);
                            } else {
                                // Partial transcription - show in gray
                                this.transcript.innerHTML = this.transcriptText +
                                    '<span class="partial">' + data.text + '</span>';
                                console.log(`Partial: "${data.text}"`);
                            }
                            this.transcript.scrollTop = this.transcript.scrollHeight;
                        } else {
                            console.log('Empty or invalid transcription text:', data.text);
                        }
                        break;

                    case 'translation':
                        console.log('Processing translation:', data);
                        if (data.text && data.text.trim()) {
                            if (data.isFinal) {
                                // Final translation - add to permanent text
                                this.translationText += data.text + ' ';
                                this.translation.innerHTML = this.translationText;
                                console.log(`Final translation: "${data.text}"`);
                            } else {
                                // Partial translation - show in gray
                                this.translation.innerHTML = this.translationText +
                                    '<span class="partial">' + data.text + '</span>';
                                console.log(`Partial translation: "${data.text}"`);
                            }
                            this.translation.scrollTop = this.translation.scrollHeight;
                        }
                        break;

                    case 'languageChangeRestart':
                        console.log('Language change restart:', data.message);
                        this.showStatus(data.message, 'listening');
                        // Don't clear previous content - just show status
                        // Previous transcriptions and translations remain visible
                        break;

                    case 'targetLanguageChanged':
                        console.log('Target language changed:', data.message);
                        this.showStatus(data.message, 'listening');
                        // Don't clear any content - just update labels if needed
                        break;

                    case 'status':
                        console.log('Status message:', data.message);
                        this.showStatus(data.message, 'listening');
                        // Check if translation is enabled from status message
                        if (data.message.includes('Translation: Enabled')) {
                            this.translationEnabled = true;
                            this.translationSection.classList.add('enabled');
                        } else if (data.message.includes('Translation: Disabled')) {
                            this.translationEnabled = false;
                            this.translationSection.classList.remove('enabled');
                            this.hideTranslationControls();
                        }
                        break;

                    case 'error':
                        console.log('Error message:', data.message);
                        this.showStatus('‚ùå Error: ' + data.message, 'error');
                        break;

                    default:
                        console.log('Unknown message type:', data.type);
                        break;
                }
            }

            updateLanguageLabels(sourceLanguage, targetLanguage) {
                const languageNames = {
                    'auto': 'Auto Detect',
                    'en': 'English', 'es': 'Spanish', 'fr': 'French', 'de': 'German',
                    'it': 'Italian', 'pt': 'Portuguese', 'ja': 'Japanese', 'ko': 'Korean',
                    'zh': 'Chinese', 'ar': 'Arabic', 'ru': 'Russian', 'hi': 'Hindi',
                    'nl': 'Dutch', 'pl': 'Polish', 'tr': 'Turkish', 'sv': 'Swedish',
                    'da': 'Danish', 'no': 'Norwegian', 'fi': 'Finnish', 'cs': 'Czech',
                    'sk': 'Slovak', 'hu': 'Hungarian', 'ro': 'Romanian', 'bg': 'Bulgarian',
                    'hr': 'Croatian', 'sl': 'Slovenian', 'et': 'Estonian', 'lv': 'Latvian',
                    'lt': 'Lithuanian', 'uk': 'Ukrainian'
                };

                this.originalLabel.textContent = `üéØ Original (${languageNames[sourceLanguage] || sourceLanguage})`;
                if (this.translationEnabled) {
                    this.translationLabel.textContent = `üåç Translation (${languageNames[targetLanguage] || targetLanguage})`;
                }
            }

            float32ToPCM16(float32Array) {
                const pcm16Array = new Int16Array(float32Array.length);
                for (let i = 0; i < float32Array.length; i++) {
                    const sample = Math.max(-1, Math.min(1, float32Array[i]));
                    pcm16Array[i] = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                }
                return pcm16Array.buffer;
            }

            showStatus(message, type) {
                this.status.textContent = message;
                this.status.className = 'status ' + type;
                this.status.style.display = message ? 'block' : 'none';
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new WhisperClient();
        });
    </script>
</body>

</html>